<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 6.0: Radau5, Hyperbolic PDEs, Dependency Reductions </title> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><h1 id=differentialequationsjl_60_radau5_hyperbolic_pdes_dependency_reductions ><a href="#differentialequationsjl_60_radau5_hyperbolic_pdes_dependency_reductions">DifferentialEquations.jl 6.0: Radau5, Hyperbolic PDEs, Dependency Reductions</a></h1> <p>This marks the release of DifferentialEquations.jl v6.0.0. Here&#39;s a low down of what has happened in the timeframe.</p> <h2 id=breaking_change_dependency_reduction_in_differentialequationsjl ><a href="#breaking_change_dependency_reduction_in_differentialequationsjl">Breaking Change: Dependency Reduction in DifferentialEquations.jl</a></h2> <p>The only big breaking change of v6.0.0 is the reduction of dependencies in DifferentialEquations.jl. We decided that with the proliferation of modeling and analysis tooling, it was bloating the dependencies to keep them all reexported from DifferentialEquations.jl and thus they were excised. Packages which were removed from the standard distribution are:</p> <ul> <li><p>ParameterizedFunctions.jl &#40;<code>@ode_def</code>&#41;</p> <li><p>DiffEqParamEstim.jl</p> <li><p>DiffEqSensitivity.jl</p> <li><p>DiffEqUncertainty.jl</p> <li><p>DiffEqBiological.jl</p> </ul> <p>This had some good consequences. For one, SymEngine.jl is no longer a dependency of DifferentialEquations.jl, meaning that it is now Python free&#33; Python&#39;s Conda package manager seems to have been the main cause of installation issues, so hopefully everyone has a better time installing DifferentialEquations.jl.</p> <p>This also means that Sundials.jl is the only remaining package with binaries that is included in DifferentialEquations.jl. That will continue to be the case until we improve our DAE solvers and match <code>CVODE_BDF</code> in the few remaining benchmarks where it does well &#40;with a Nordsieck BDF method of our own due to Yingbo Ma&#33;&#41;. To prepare for the removal of Sundials.jl from the base install of DifferentialEquations.jl, we have decided to stop reexporting Sundials. This means that Sundials will still be used &#40;for now&#41; in the default argument handling, but <strong>if you would like to explicitly set a method to use a Sundials method like <code>CVODE_BDF</code> or <code>IDA</code>, you need to add <code>using Sundials</code></strong>. The documentation has been updated to reflect this fact. We hope that during the v6.0 timeframe our differential-algebraic equation methods will be sufficiently developed so that we can remove Sundials.jl from the dependencies, and by removing the reexport now this change can occur without breaking code in the near future.</p> <p>The breaking consequence is that if you use any of the functionality provided by these packages, you now need to include the <code>using</code> statement. For example, <strong>if you use <code>@ode_def</code>, you need to do <code>using ParameterizedFunctions</code> before that</strong>. The documentation has been updated so that all of the pages which explore this extra functionality explicitly mentions what <code>using</code> statement needs to be done. We are still keeping the unified documentation and the unified testing, since this is what we believe makes the JuliaDiffEq ecosystem so easy to use and a powerful scientific tool.</p> <p>In the end, some codes will need to be updated to add a few <code>using</code> statements, but the vast majority of users will enjoy our march to a hassle-free pure-Julia DifferentialEquations.jl installation.</p> <h2 id=a_few_other_minor_breaking_changes ><a href="#a_few_other_minor_breaking_changes">A Few Other Minor Breaking Changes</a></h2> <p>These ones are small enough or not harmful enough that the majority of users will likely not notice them, but it&#39;s worth mentioning:</p> <ul> <li><p><code>timeseries_steps</code> has been removed since no one used that option. Use <code>saveat</code> instead.</p> <li><p><code>problem_new_parameters</code> was removed in favor of <code>remake</code>.</p> <li><p>Type parameters were added to <code>DEIntgrator</code>, making it <code>DEIntegrator&#123;alg,iip,uType,tType&#125;</code>. Existing codes which dispatch on DEIntegrator will still work without the type parameters, so this is not breaking in a user-facing way.</p> <li><p><code>internalnorm</code> now takes <code>&#40;u,t&#41;</code>. The second argument can be used for properly dispatching on the time type &#40;units, autodiff&#41;, or for scaling adaptivity over time. <code>internalnorm</code> has been added to the common interface documentation.</p> </ul> <h2 id=scaling_enhancements_in_diffeqbiologicaljl ><a href="#scaling_enhancements_in_diffeqbiologicaljl">Scaling Enhancements in DiffEqBiological.jl</a></h2> <p>Sam Isaacson &#40;@isaacsas&#41; has done some amazing work with jump equation methods and DiffEqBiological.jl. One improvement is the <code>@min_reaction_network</code> macro which allows for incrementally building the necessary functions from the system:</p> <pre><code class="julia hljs">sir_model = <span class=hljs-meta >@min_reaction_network</span> SIR <span class=hljs-keyword >begin</span>
           c1, s + i --&gt; <span class=hljs-number >2</span>i
           c2, i --&gt; r
       <span class=hljs-keyword >end</span> c1 c2
addodes!(sir_model)
addsdes!(sir_model)
addjumps!(sir_model)</code></pre> <p>This in addition with some other structural changes has allowed the DSL to scale to test problems of ~25,000 reactions &#40;i.e. that&#39;s as large as we&#39;ve tested so far&#41;, making it suitable for large interaction networks.</p> <h2 id=fully_implicit_runge-kutta_firk_methods_radau5 ><a href="#fully_implicit_runge-kutta_firk_methods_radau5">Fully Implicit Runge-Kutta &#40;FIRK&#41; Methods: Radau5</a></h2> <p>Yingbo Ma &#40;@yingboma&#41; has added a native implementation of Hairer&#39;s Radau5. Unlike simple implementations, it utilizes the domain transformation of the tableau into the complex plane for enhanced efficiency just like the original Fortran code. This is our first foray into FIRK methods, where we will be handling the other order Radaus, an adaptive order Radau, and all sorts of other methods. These methods are especially good for high accuracy integration of stiff ODEs, so we can&#39;t wait to test them when mixed with high precision number types&#33;</p> <h2 id=rock4_and_rkc ><a href="#rock4_and_rkc">ROCK4 and RKC</a></h2> <p>A new contributor, Deepesh Singh Thakur &#40;@deeepeshthakur&#41;, has implemented the <code>ROCK4</code> and <code>RKC</code> methods. These are higher order and more efficient versions of the <code>ROCK2</code> method which we previously released. These methods are able to solve semi-stiff ODEs without requiring a Jacobian or factorizations, meaning that they can be much more efficient when only mild stiffness is present. Cases where these methods are known to perform well are discretizations of parabolic PDEs like Reaction-Diffusion equations. Watch for these in the benchmarks.</p> <h2 id=anderson_acceleration ><a href="#anderson_acceleration">Anderson Acceleration</a></h2> <p>New contributor Kanav Gupta &#40;@kanav99&#41; has implemented Anderson Acceleration in the OrdinaryDiffEq.jl nonlinear solver handling. This is a kind of nonlinear solver which is more stable and faster than functional iteration, but doesn&#39;t require the factorization of the full Jacobian matrix like Newton&#39;s method. This can result in speed improvements for many stiff integrators. We are investigating the effects of this method, and will be porting it over to StochasticDiffEq.jl and DelayDiffEq.jl.</p> <h2 id=hyperbolic_pde_method_extravaganza ><a href="#hyperbolic_pde_method_extravaganza">Hyperbolic PDE Method Extravaganza</a></h2> <p>Many new contributors have added methods which are useful for the integration of hyperbolic PDE discretizations. Divyanshu Gupta &#40;@dgan181&#41;, Saurabh Agarwal &#40;@saurabhkgp21&#41;, Arnav Tiwari &#40;@arnav-t&#41;, and Deepesh Singh Thakur &#40;@deeepeshthakur&#41; have all contributed methods which have high SSP coefficients &#40;PDE stability&#41;, low memory requirements, and/or low dispersion. We know some of you reading these are especially interested in applications of these methods, so please take a look at the updated ODE solver documentation for more information.</p> <h2 id=integration_with_neural_networks ><a href="#integration_with_neural_networks">Integration with Neural Networks</a></h2> <p>DifferentialEquations.jl is now integrated with the Flux.jl platform with DiffEqFlux.jl. For more information, please see our <a href="https://sciml.ai/blog/2019/01/fluxdiffeq">release blog post</a>.</p> <h2 id=tons_and_tons_of_small_fixes ><a href="#tons_and_tons_of_small_fixes">Tons and Tons of Small Fixes</a></h2> <p>These last few months have been relatively quiet for the JuliaDiffEq blog and this is why. The incorporation of neural networks, building a pharmacometrics library PuMaS.jl, lots of physicists picking up DifferentialEquations.jl, etc. meant that a lot of time was spent polishing up the more obscure type handling. Dealing with complex numbers, dual numbers, tracked values, heterogenous units, etc. all got overhauls and testing. There is still some work needed in some areas, such as using stiff ODE solvers on static arrays, and these will continue to get improvements.</p> <h1 id=in_development ><a href="#in_development">In development</a></h1> <p>And here&#39;s a quick view of the rest of our &quot;in development&quot; list. These are not necessarily &quot;prioritized&quot;, but it&#39;s the kinds of things we are looking to get done.</p> <ul> <li><p>Ubiquitous within-method GPU parallelism for pure-Julia methods</p> <li><p>Better boundary condition handling in DiffEqOperators.jl</p> <li><p>More native implicit ODE &#40;DAE&#41; solvers</p> <li><p>Preconditioner choices for Sundials methods</p> <li><p>Easier interface for Newton-Krylov in native Julia methods</p> <li><p>More adaptive methods for SDEs</p> <li><p>Adaptivity in the MIRK BVP solvers</p> <li><p>LSODA integrator interface</p> <li><p>Fixed Leading Coefficient &#40;FLC&#41; form Nordsieck BDF integrators</p> <li><p>More FIRK, IMEX, extrapolation, and stabilized-explicit methods</p> <li><p>More comprehensive benchmarks</p> <li><p>Parameter estimation and global sensitivity improvements</p> </ul> <h1 id=google_summer_of_code_projects ><a href="#google_summer_of_code_projects">Google Summer of Code Projects</a></h1> <p>Are you a student who is interested in working on differential equations software and modeling? If so, please get in touch with us since we many Google Summer of Code projects available&#33; <a href="https://sciml.ai/soc/projects/diffeq.html">Take a look at our projects list on the Julia webpage</a></p> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>