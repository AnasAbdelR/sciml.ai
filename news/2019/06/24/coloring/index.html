<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl v6.6.0: Sparse Jacobian Coloring, Quantum Computer ODE Solvers, and Stiff SDEs </title> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><h2 id=sparsity_performance_jacobian_coloring_with_numerical_and_forward_differentiation ><a href="#sparsity_performance_jacobian_coloring_with_numerical_and_forward_differentiation">Sparsity Performance: Jacobian coloring with numerical and forward differentiation</a></h2> <p>If you have a function <code>f&#33;&#40;du,u&#41;</code> which has a Tridiagonal Jacobian, you could calculate that Jacobian by mixing perturbations. For example, instead of doing <code>u .&#43; &#91;epsilon,0,0,0,0,0,0,0,...&#93;</code>, you&#39;d do <code>u .&#43; &#91;epsilon,0,0,epsilon,0,0,...&#93;</code>. Because the <code>epsilons</code> will never overlap, you can then decode this &quot;compressed&quot; Jacobian into the sparse form. Do that 3 times and boom, full Jacobian in 4 calls to <code>f&#33;</code> no matter the size of <code>u</code>&#33; Without a color vector, this matrix would take <code>1&#43;length&#40;u&#41;</code> <code>f&#33;</code> calls, so I&#39;d say that&#39;s a pretty good speedup.</p> <p>This is called Jacobian coloring. <code>&#91;1,2,3,1,2,3,1,2,3,...&#93;</code> are the colors in this example, and places with the same color can be differentiated simultaneously. Now, the DiffEqDiffTools.jl internals allow for passing a color vector into the numerical differentiation libraries and automatically decompressing into a sparse Jacobian. This means that DifferentialEquations.jl will soon be compatible with this dramatic speedup technique. In addition, other libraries in Julia with rely on our utility libraries, like Optim.jl, could soon make good use of this.</p> <p>What if you don&#39;t know a good color vector for your Jacobian? No sweat&#33; The soon to be released SparseDiffTools.jl repository has methods for automatically generating color vectors using heuristic graphical techniques. DifferentialEquations.jl will soon make use of this automatically if you specify a sparse matrix for your Jacobian&#33;</p> <p>Note that the SparseDiffTools.jl repository also includes functions for calculating the sparse Jacobians using color vectors and forward-mode automatic differentiation &#40;using Dual numbers provided by ForwardDiff.jl&#41;. In this case, the number of Dual partials is equal to the number of colors, which can be dramatically lower than the <code>length&#40;u&#41;</code> &#40;the dense default&#33;&#41;, thereby dramatically reducing compile and run time.</p> <p>Stay tuned for the next releases which begin to auto-specialize everything along the way based on sparsity structure. Thanks to JSoC student Pankaj &#40;@pkj-m&#41; for this work.</p> <h2 id=higher_weak_order_srock_methods_for_stiff_sdes ><a href="#higher_weak_order_srock_methods_for_stiff_sdes">Higher weak order SROCK methods for stiff SDEs</a></h2> <p>Deepesh Thakur &#40;@deeepeshthakur&#41; continues his roll with stiff stochastic differential equation solvers by implementing not 1 but 7 new high weak order stiff SDE solvers. SROCK1 with generalized noise, SKSROCK, and a bunch of variants of SROCK2. Benchmark updates will come soon, but I have a feeling that these new methods may be by far the most stable methods in the library, and the ones which achieve the lowest error in the mean solution most efficiently.</p> <h2 id=diffeqbot ><a href="#diffeqbot">DiffEqBot</a></h2> <p>GSoC student Kanav Gupta &#40;@kanav99&#41; implemented a bot for the JuliaDiffEq team that allows us to run performance regression benchmarks on demand with preset Gitlab runners. Right now this has a dedicated machine for CPU and parallelism performance testing, and soon we&#39;ll have a second machine up and running for performance testing on GPUs. If you haven&#39;t seen the Julialang blog post on this topic, <a href="https://sciml.ai/blog/2019/06/diffeqbot">please check it out&#33;</a>.</p> <h2 id=quantum_ode_solver_qulde ><a href="#quantum_ode_solver_qulde">Quantum ODE Solver QuLDE</a></h2> <p>If you happen to have a quantum computer handy, hold your horses. <code>QuLDE</code> from QuDiffEq.jl is an ODE solver designed for quantum computers. It utilizes the Yao.jl quantum circuit simulator to run, but once Yao.jl supports QASM then this will compile to something compatible with &#40;future&#41; quantum computing hardware. This means that, in order to enter the new age of computing, all you have to do is change <code>solve&#40;prob,Tsit5&#40;&#41;&#41;</code> to <code>solve&#40;prob,QuLDE&#40;&#41;&#41;</code> and you&#39;re there. Is it practical? Who knows &#40;please let us know&#41;. Is it cool? Oh yeah&#33;</p> <p>See <a href="https://nextjournal.com/dgan181/julia-soc-19-quantum-algorithms-for-differential-equations">the quantum ODE solver blog post for more details</a>.</p> <h2 id=commutative_noise_gpu_compatibility ><a href="#commutative_noise_gpu_compatibility">Commutative Noise GPU compatibility</a></h2> <p>The commutative noise SDE solvers are now GPU-compatible thanks to GSoC student Deepesh Thakur &#40;@deeepeshthakur&#41;. The next step will be to implement high order non-commutative noise SDE solvers and the associated iterated integral approximations in a manner that is GPU-compatible.</p> <h2 id=new_benchmark_and_tutorial_repository_setups ><a href="#new_benchmark_and_tutorial_repository_setups">New benchmark and tutorial repository setups</a></h2> <p>DiffEqBenchmarks.jl and DiffEqTutorials.jl are now fully updated to a Weave.jl form. We still need to fix up a few benchmarks, but it&#39;s in a state that is ready for new contributions.</p> <h2 id=optimized_multithreaded_extrapolation ><a href="#optimized_multithreaded_extrapolation">Optimized multithreaded extrapolation</a></h2> <p>The GBS extrapolation methods have gotten optimized, and they now are the one of the most efficient methods at lower tolerances of the Float64 range for non-stiff ODEs:</p> <p><img src="https://user-images.githubusercontent.com/1814174/59899185-d56a5e80-93c1-11e9-86a0-ea09bfaa59ed.png" alt="non-stiff extrapolation" /></p> <p>Thank you to Konstantin Althaus &#40;@AlthausKonstantin&#41; for contributing the first version of this algorithm and GSoC student Saurabh Agarwal &#40;@saurabhkgp21&#41; for adding automatic parallelization of the method.</p> <p>This method will soon see improvements as multithreading will soon be improved in Julia v1.2. The new PARTR features will allow our internal <code>@threads</code> loop to perform dynamic work-stealing which will definitely be a good improvement to the current parallelism structure. So stay tuned: this will likely benchmark even better in a few months.</p> <h2 id=fully_non-allocating_exp_in_exponential_integrators ><a href="#fully_non-allocating_exp_in_exponential_integrators">Fully non-allocating exp&#33; in exponential integrators</a></h2> <p>Thanks to Yingbo Ma &#40;@YingboMa&#41; for making the internal <code>exp</code> calls of the exponential integrators non-allocating. Continued improvements to this category of methods is starting to show promise in the area of semilinear PDEs.</p> <h2 id=rosenbrock-w_methods ><a href="#rosenbrock-w_methods">Rosenbrock-W methods</a></h2> <p>JSoC student Langwen Huang &#40;@huanglangwen&#41; has added the Rosenbrock-W class of methods to OrdinaryDiffEq.jl. These methods are like the Rosenbrock methods but are able to reuse their W matrix for multiple steps, allowing the method to scale to larger ODEs more efficiently. Since the Rosenbrock methods benchmark as the fastest methods for small ODEs right now, this is an exciting new set of methods which will get optimized over the course of the summer. Efficient Jacobian reuse techniques and the ability to utilize the sparse differentiation tooling are next on this project.</p> <h1 id=next_directions ><a href="#next_directions">Next Directions</a></h1> <p>Our current development is very much driven by the ongoing GSoC/JSoC projects, which is a good thing because they are outputting some really amazing results&#33;</p> <p>Here&#39;s some things to look forward to:</p> <ul> <li><p>Higher order SDE methods for non-commutative noise</p> <li><p>Parallelized methods for stiff ODEs</p> <li><p>Integration of sparse colored differentiation into the differential equation solvers</p> <li><p>Jacobian reuse efficiency in Rosenbrock-W methods</p> <li><p>Exponential integrator improvements</p> <li><p>Native Julia fully implicit ODE &#40;DAE&#41; solving in OrdinaryDiffEq.jl</p> <li><p>Automated matrix-free finite difference PDE operators</p> <li><p>Surrogate optimization</p> <li><p>GPU-based Monte Carlo parallelism</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>