<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 3.2: Expansion of Event Compatibility </title> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><h1 id=differentialequationsjl_32_expansion_of_event_compatibility ><a href="#differentialequationsjl_32_expansion_of_event_compatibility">DifferentialEquations.jl 3.2: Expansion of Event Compatibility</a></h1> <p>DifferentialEquations.jl 3.2 is just a nice feature update. This hits a few long requested features.</p> <h2 id=integrators_callbacks_and_events_with_sundials ><a href="#integrators_callbacks_and_events_with_sundials">Integrators, Callbacks, and Events with Sundials</a></h2> <p>The callbacks, both <code>DiscreteCallback</code> and <code>ContinuousCallback</code>, are now able to be used with the Sundials.jl solvers. This includes <code>IDA</code>, the DAE solver, as well. This was one of the most requested features for a long time and, well, it&#39;s here&#33; Also, <code>tstops</code> works with Sundials as well, meaning that all of the tricks used for building complex control schemes can now work with Sundials.jl. Additionally, the integrator interface for controlling Sundials via an iterator exists as well. Note that not all of the integrator interface functions are implemented right now, but at this point implementing most of them is quite simple. So please feel free to open feature requests and we can tackle them as needed.</p> <p>Sundials.jl is now very well integrated into the DiffEq ecosystem. It&#39;s compatible with almost every option. The things it&#39;s not compatible with, such as arbitrary number types, do not seem to fit into the main purposes of its schemes anyways. The multistep schemes from this library are most efficient in cases where the user&#39;s <code>f</code> is expensive or the number of ODEs is large. In these cases, arbitrary precision is infeasible anyways. Thus, since Sundials is a very well-optimized library, I am putting the development of a native Julia multistep method on the backburner. Instead, I think the next goals in this domain should be to finish getting full compatibility of Sundials with the common interface, and that includes the ability to pass preconditioners, user-defined banded Jacobians, and ARKODE. Getting those setup with our simple interfaces will make powerful PDE solving tools and there&#39;s no reason to double our efforts here.</p> <h2 id=callbacks_and_events_with_odeinterface_and_some_performance_improvements ><a href="#callbacks_and_events_with_odeinterface_and_some_performance_improvements">Callbacks and Events with ODEInterface &#40;and some performance improvements&#41;</a></h2> <p>In the same vein as above, ODEInterface.jl&#39;s common interface bindings are now compatible with our callback interfaces. This library is now controlled at a much lower level where we handle its stepping through its output functions. There&#39;s a few other things which are gained from this. First of all, we more directly save information that we want, so this actually gives a performance gain. Secondly, this allowed us to use <code>saveat</code> with the intermediate dense output. Thus while the solution given to the user only has a linear dense output due to restrictions of the library, within each step <code>saveat</code> and <code>ContinuousCallback</code>s are able to make use of the libraries internal higher order interpolation.</p> <p>The end result is that these functions are very compatible with the common interface now. There are two big exceptions. This library will not be compatible with <code>tstops</code>, and it cannot have the full <code>integrator</code> interface &#40;i.e. instead of <code>solve</code>, using <code>init</code>&#41;. This is due to how the core integration functions are written in FORTRAN. However, instead of using <code>tstops</code> with a <code>DiscreteCallback</code>, one can always make use of a <code>ContinuousCallback</code>, so it&#39;s not terrible.</p> <p>But this means that useful algorithms like <code>radau</code>, <code>seulex</code> now have all of the tools to be used with event handling and the like. Thus, for the same reasons as with Sundials, remaking <code>radau</code> into a native Julia version is now lower on the priority list. Instead, getting this library setup with user-defined banded Jacobians would satisfy most users in this department, so I plan on hitting that up soon and then tackling other areas.</p> <h2 id=expanded_benchmarks ><a href="#expanded_benchmarks">Expanded Benchmarks</a></h2> <p><a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">DiffEqBenchmarks.jl</a> got a huge update. The nonstiff ODE problems now showcase more algorithms like lsoda and ddeabm. There are a lot of new stiff ODE test problems and they cover a wide range of algorithms. There&#39;s new tooling which allows for generating work-precision plots of stochastic differential equations without analytical solutions &#40;for both strong and weak error&#41; which is showing some really interesting results that showcase the efficiency of high order adaptive methods.</p> <h2 id=arrays_of_static_arrays ><a href="#arrays_of_static_arrays">Arrays of Static Arrays</a></h2> <p>Nested arrays can be a natural way to represent a problem. The <code>*</code>DiffEq libraries can now handle these nested arrays of static arrays. One user reported a speedup of 4x by using this to represent their equation.</p> <h2 id=new_wrapped_libraries ><a href="#new_wrapped_libraries">New Wrapped Libraries</a></h2> <p>We welcome Bridge.jl and GeometericIntegrators.jl wrappers to the DiffEq-sphere. Bridge.jl is a library for stochastic calculus and it has some nice out-of-place fixed timestep solvers for stochastic differential equations. GeometericIntegrators.jl is a library of fixed timestep solvers which will likely be focusing on geometric and conservative algorithms. Following the theme of not doubling efforts across the Julia ecosystem, these wrappers expand our focus with less effort.</p> <h1 id=in_development ><a href="#in_development">In development</a></h1> <p>The &quot;in development&quot; list has falling sharply. First of all, many things have finished. Other things are being left for Google Summer of Code. But mainly, the increased compatibility of wrapped packages allows us to shift focus. While there would still be advantages of a pure-Julia BDF or Radau method, the advantages, now that these are compatible with even more advanced features like event handling, are minimal. Thus these have been shifted to a lower priority, allowing us to shift our focus.</p> <p>Thus the main current &quot;in development&quot; list is:</p> <ul> <li><p>IMEX and Exponential Integrators</p> <li><p>Improved jump methods &#40;tau-leaping&#41;</p> <li><p>Stiff SDE solvers</p> <li><p>Banded and sparse Jacobian support</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>