<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title>DifferentialEquations.jl v1.9.1</title> <header> <h1><b><center>SciML</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>DifferentialEquations v1.9.1 is a feature update which, well, brings a lot of new features. But before we get started, there is one thing to highlight:</p> <h1 id=planned_api_changes ><a href="#planned_api_changes">Planned API Changes</a></h1> <p>I first want to highlight upcoming API changes so that users can be aware. These are changes that have been discussed for quite awhile. I would like to make these changes before the JuliaCon workshop &quot;sets in stone&quot; the API. Most of the changes are rather minor.</p> <p><strong>NOTE: Please feel free to comment in the issues&#33; APIs are for the users, and so if there&#39;s anything you think would make things easier to use, now is the time to say something&#33;</strong></p> <h2 id=proposed_saving_api_changes ><a href="#proposed_saving_api_changes">Proposed Saving API Changes</a></h2> <p><a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/132">https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/132</a> <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/133">https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/133</a> <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/139">https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/139</a></p> <p>These changes detail changes in how one can specify timepoints to save. The summary is:</p> <ul> <li><p>If you give <code>saveat</code> a scalar, it will save at the timepoints <code>tspan&#91;1&#93;:saveat_num:tspan&#91;end&#93;</code>.</p> <li><p>Using <code>saveat</code> will default <code>save_timeseries</code> to false, meaning that if you set <code>saveat</code>, it will only save at the points you requested. This will also turn off dense output. These can then manually be turned on via <code>save_timeseries&#61;true,dense&#61;true</code>. Note that these will still default to true when no <code>saveat</code> is given. The reasoning is that, if you choose <code>saveat</code> points, you likely only want those timepoints&#33;</p> <li><p><code>save_timeseries</code> will be renamed <code>save_everystep</code>. There have been lots of questions about what this argument means, and the name change should clarify it.</p> <li><p><code>saveat_idxs</code>: Allows you to choose which components to save. This way you can save memory and simply save the components you want. Not every solver will be able to support this, but the <code>*DiffEq</code> methods will for sure.</p> </ul> <h2 id=proposed_parameterizedfunction_changes ><a href="#proposed_parameterizedfunction_changes">Proposed ParameterizedFunction Changes</a></h2> <p>There is a lot of bikeshedding for the future of the <code>@ode_def</code> DSL. For information, please see:</p> <p><a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl/issues/17">https://github.com/JuliaDiffEq/ParameterizedFunctions.jl/issues/17</a></p> <p>Essentially, the breaking change will be <code>x_t</code> instead of <code>dx</code> for writing the derivative part &#40;meaning derivative in time&#41;. This makes it easier to carry over into things like PDEs and DAEs. While this is breaking, this should be a very simple fix.</p> <h2 id=proposed_solution_indexing_change ><a href="#proposed_solution_indexing_change">Proposed Solution Indexing Change</a></h2> <p>There is a question as to whether we should keep the <code>sol&#91;:,i&#93;</code> as the way to get the timeseries for the <code>i</code>th component, or change that to <code>sol&#91;i,:&#93;</code>. The reason this was originally chosen was because it&#39;s stored as a vector of arrays, so it naturally indexes like <code>sol&#91;:&#93;&#91;i&#93;</code>. However, since indexing &quot;within the same timepoint&quot; is faster, this convention breaks column-major ordering which is prevalent in Julia. Thus with <code>sol&#91;i,:&#93;</code>, it would be more apparent that the faster indexing is the inner indexing. The full proposal is here:</p> <p><a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/152">https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/152</a></p> <p>While this is likely not going to be a huge internal change, it is a breaking change which can get opinioned. Whatever the indexing choice is, this setup will be made more generic for a wrapper of <code>VectorOfArray</code>s, making it &quot;more standard&quot; throughout the diffeq ecosystem.</p> <h1 id=new_features ><a href="#new_features">New Features</a></h1> <p>Now, onto the new features&#33;</p> <h2 id=two-stage_parameter_estimation_method ><a href="#two-stage_parameter_estimation_method">Two-stage Parameter Estimation Method</a></h2> <p>This change is by a new contributor, Ayush Pandey. The Two-stage method is a statistical method for estimating the parameters of ODE systems. While restricted to ODEs, it&#39;s a very robust method which can be used to get the general ballpark for parameters even when the model is slightly wrong. Since it does not actually require solving the ODEs, it is a very fast method as well. One very good use of this method is to get an approximate answer, which can then be refined with the nonlinear regression approaches.</p> <p>This method will be added to the documentation in the near future. Many more updates to parameter estimation are planned, such as likelihood and Bayesian techniques.</p> <h2 id=parameter_interface ><a href="#parameter_interface">Parameter Interface</a></h2> <p>This is more of a development change, but I wanted to mention that the parameter interface has been refined to work entirely off of dispatches. This means that the development tools can query for the parameters of problems which even have parameters on multiple different functions. A good example is an <code>SDEProblem</code> which has parameters on both <code>f</code> and <code>g</code>.</p> <p>A side effect is that now the parameter estimation tools are compatible with more than just <code>ODEProblem</code> types: it&#39;s compatible with any <code>DEProblem</code>. This brings me to my next point.</p> <h2 id=big_monte_carlo_updates ><a href="#big_monte_carlo_updates">Big Monte Carlo Updates</a></h2> <p>The changes to the Monte Carlo interface is large. To see how to use the newest version of this interface, see the documentation page here:</p> <p><a href="https://docs.juliadiffeq.org/latest/features/ensemble">https://docs.juliadiffeq.org/latest/features/ensemble</a></p> <p>The biggest part of this change is that now you can specify how the simulations are reduced, instead of saving the solution object each time. Thus you can specify an <code>output_func</code> and just save the last value of the 1st component, allowing you to run millions of simulations without running out of memory.</p> <p>In addition, the setup is now along the lines of creating a <code>MonteCarloProblem</code> and calling <code>solve</code> on this problem. Because of this, a few things happen. First of all, solving Monte Carlo problems is now naturally compatible with addons of the common solve interface. But secondly, the dispatches on the parameter interface can apply, meaning different parts of the <code>MonteCarloProblem</code> can be parameterized. This means that parameter estimation routines can be run to estimate parameters using Monte Carlo simulations&#33; Optimize the mean-squared error over many replicates of a stochastic problem, and estimate population parameters.</p> <h2 id=bifucation_analysis_provided_by_pydstool ><a href="#bifucation_analysis_provided_by_pydstool">Bifucation Analysis Provided By PyDSTool</a></h2> <p>PyDSTool.jl is a new wrapper for the Python library PyDSTool. While it can do things like solve ODEs, those features are not of much use. However, with this wrapper comes PyCont, a library for continuation &#40;bifurcation plots&#41;. You can see an example for making bifurcation plots here:</p> <p><a href="https://docs.juliadiffeq.org/latest/analysis/bifurcation">https://docs.juliadiffeq.org/latest/analysis/bifurcation</a></p> <p>This is in its very early stages, but now that it is working all that&#39;s left are API improvements&#33; But note that it&#39;s currently disabled due to a Windows bug with PyCall&#39;s latest release. This will be fixed very soon, and DifferentialEquations will be patched in a way that makes PyDSTool.jl a standard tool in the ecosystem.</p> <h2 id=retcodes ><a href="#retcodes">Retcodes</a></h2> <p>Retcodes are hard to make sexy, but they are useful.</p> <p><a href="https://docs.juliadiffeq.org/latest/basics/solution">https://docs.juliadiffeq.org/latest/basics/solution</a></p> <p>Now the solvers have a set way to tell you if the solver was successful, or why it exited pre-maturely. This setup will grow overtime, but is already fully functional.</p> <h2 id=callback_initialize ><a href="#callback_initialize">Callback Initialize</a></h2> <p>Callbacks are now allowed to have an <code>initialize</code> function which will be run before a simulation begins. Thus if you need to initiate some random event at the start of a simulation, or set some values in the callback using values from the problem, callbacks can do this.</p> <h2 id=jump_improvements ><a href="#jump_improvements">Jump Improvements</a></h2> <p>The Gillespie-type jumping models have improved behavior. Before, the starting random numbers would only be generated on construction of the jump type. This lead to some weird behavior. But initiating a new first jump using the callback initialization phase, every simulation will have a different first jump just by calling <code>solve</code> another time.</p> <h2 id=function_plotting ><a href="#function_plotting">Function Plotting</a></h2> <p>Now you can choose a function to be called on the plotted points. This allows you to easily do things like plot the norm of the solution over time. For more information, please see the improved plotting docs:</p> <p><a href="https://docs.juliadiffeq.org/latest/basics/plot">https://docs.juliadiffeq.org/latest/basics/plot</a></p> <h2 id=splitodeproblem_types ><a href="#splitodeproblem_types">SplitODEProblem Types</a></h2> <p>The <code>SplitODEProblem</code> is the generic diffeq answer to IMEX problems. It was implemented by a new contributor Om Prakash. These allow you give define an ODE by a tuple of functions instead of a single function. Solvers can then use these components separately. This is sufficient for specifying any PDE method, and so we will be using this to implement PDE methods. Docs will be added when the solvers which make use of this are created.</p> <h2 id=ssprk_method ><a href="#ssprk_method">SSPRK Method</a></h2> <p>This was implemented by a new contributor Hendrik Ranocha. These methods are higher-order methods which are capable of solving the semi-discretizations arising form hyperbolic partial differential equations which have some discontinuities. You can find these algorithm choices in the docs:</p> <p><a href="https://docs.juliadiffeq.org/latest/solvers/ode_solve">https://docs.juliadiffeq.org/latest/solvers/ode_solve</a></p> <h2 id=splitcoupling ><a href="#splitcoupling">SplitCoupling</a></h2> <p>This was implemented by a new contributor Ethan Levien. Split coupling of jumps allows the variance of Monte Carlo estimates to be reduced, allowing you to estimate moments estimators with less runs. He is developing a more general approach which will extend the Monte Carlo setup and do things like Multi-Level Monte Carlo.</p> <p>Docs for this coming soon.</p> <h1 id=coming_soon_google_summer_of_code ><a href="#coming_soon_google_summer_of_code">Coming Soon: Google Summer of Code</a></h1> <p>Many Google Summer of Code &#40;GSoC&#41; applications went in for JuliaDiffEq. This means there is a lot of potential GSoC activity over the summer with new contributors &#40;students&#41; expanding the ecosystem. A post will detail what these project will be about when more information is known. This will likely guide a good portion of JuliaDiffEq summer activity.</p> </div>