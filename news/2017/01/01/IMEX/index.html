<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title>DifferentialEquations.jl 3.3: IMEX Solvers</title> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>What&#39;s a better way to ring in the new year than to announce new features? This ecosystem 3.3 release we have a few exciting developments, and at the top of the list is new IMEX schemes. Let&#39;s get right to it.</p> <h2 id=additive_runge-kutta_schemes_for_implicit-explicit_problems ><a href="#additive_runge-kutta_schemes_for_implicit-explicit_problems">Additive Runge-Kutta Schemes for Implicit-Explicit Problems</a></h2> <p>Using an implicit solver is required for solving a stiff differential equation. However, an implicit solver has to solve a rootfinding problem every step which takes considerable computational resources. What if there was a way so that the solver was only implicit for certain parts of the equation?</p> <p>Enter the IMEX problems. Instead of defining an ODE like</p> <pre><code class="julia hljs">u&#x27; = f(t,u)</code></pre>
<p>we can instead define the ODE like:</p>
<pre><code class="julia hljs">u&#x27; = f1(t,u) + f2(t,u)</code></pre>
<p>Then we can designate one of these parts as &quot;stiff&quot; and &quot;non-stiff&quot;, and do only the implicit solving of one of these functions. The hope is that the cheaper function is the one that&#39;s implicit, and thus the net cost of solving the differential equation is drastically reduced.</p>
<p>The main method for solving like this are additive Runge-Kutta schemes. The most well-regarded schemes are due to Kennedy and Carpenter, names you may recognize from the ESDIRK <code>KenCarp</code> schemes. Our <code>KenCarp</code> methods can now make use the full IMEX formulation. The documentation shows that <a href="https://docs.juliadiffeq.org/latest/types/split_ode_types">defining a <code>SplitODEProblem</code></a> is as easy as giving the two functions, and then you just choose <a href="https://docs.juliadiffeq.org/latest/solvers/split_ode_solve">one of the <code>KenCarp</code> methods</a> and now it works in the IMEX fashion. These methods are well-known for being highly efficient integrators for discretizations of large PDEs like convection-reaction-diffusion equations but they are usually relegated to more niche solvers like the ARKODE library of Sundials. However, now it&#39;s directly available in DifferentialEquations.jl, and these are native Julia implementations so they are compatible with all of the event, number type, etc. goodies.</p>
<h2 id=false_position_method_for_event_handling ><a href="#false_position_method_for_event_handling">False Position Method for Event Handling</a></h2>
<p>All of the <code>ContinuousCallback</code> solvers utilize false position methods for solving the rootfinding problem. Previously bisection was used but we found this to give substantial speedups. Classic solvers like those in Sundials have always made use of the Illinois false position method, but we ran the gambit of newer versions and found one that&#39;s one efficient &#40;we are actually just using <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl for this... so thanks&#33;&#41;</a>&#41;. The net result shows that bypassing rootfinding algorithms of other libraries was more efficient, so that means that wrapped solvers like <code>CVODE_BDF</code> make use of native Julia handling for the event handling portions instead of relying on the rootfinding built into these solvers. The main point I am trying to hit here is that if you have a lot of <code>ContinuousCallback</code>s that trigger often, then you will see a speedup and it seems our architecture is very well-optimized now ecosystem wide &#40;at least in comparison to other libraries&#41;.</p>
<h2 id=general_ida_fixes ><a href="#general_ida_fixes">General IDA Fixes</a></h2>
<p>In this last release there was a lot of interest in the new event handling with <code>IDA</code>, which led to bug reports and fixes. Initial condition consistency handling, linear solver choices, reinitialization after callbacks were all fixed or made more robust. The test suite was also greatly expanded and so we hope this can now serve as a robust almost feature-complete general purpose fully implicit DAE solver with event handling&#33;</p>
<h1 id=in_development ><a href="#in_development">In development</a></h1>
<p>We note that a huge update to the stochastic differential equation solvers is right around the corner: stay tuned. In addition, note that some projects have been sectioned off as <a href="https://sciml.ai/soc/projects/diffeq.html">possible GSoC projects</a>. These would also do well as new contributor projects if anyone&#39;s interested, and so these are not considered in the &quot;in development&quot; list as we are leaving these open for newcomers/students.</p>
<p>Putting those aside, this is the main current &quot;in development&quot; list:</p>
<ul>
<li><p>Preconditioner choices for Sundials methods</p>

<li><p>Small feature requests &#40;for changing initial conditions, etc.&#41;</p>

<li><p>Improved jump methods &#40;tau-leaping&#41;</p>

<li><p>Adaptivity in the MIRK BVP solvers</p>

<li><p>More general Banded and sparse Jacobian support &#40;outside of Sundials&#41;</p>

</ul>
<div class=page-foot >
  <div class=copyright >
    Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language.
  </div>
</div>
</div>