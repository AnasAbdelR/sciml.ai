<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title>PDEs Update</title> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/dev/">Dev Programs</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> | <a href="https://numfocus.org/donate-to-sciml">Donate</a> </nav> </header> <div class=franklin-content ><h1 id=pdes_update ><a href="#pdes_update">PDEs Update</a></h1> <p>Tags since the last blog post:</p> <ul> <li><p>https://github.com/JuliaLang/METADATA.jl/pull/7396</p> <li><p>https://github.com/JuliaLang/METADATA.jl/pull/7415</p> <li><p>https://github.com/JuliaLang/METADATA.jl/pull/7417</p> <li><p>https://github.com/JuliaLang/METADATA.jl/pull/7418</p> </ul> <p>The first three are all related to changes to the PDE libraries. Essentially, FiniteElementDiffEq.jl was in the stone ages: it had an old API which did not match the rest of DiffEq due to age, had some performance issues, and it did not do well with dependency handling. This was all addressed. FiniteElementDiffEq.jl was split to make DiffEqPDEBase.jl, a Base library for holding all of the PDE components, separate from FiniteElementDiffEq.jl.</p> <p>DiffEqPDEBase.jl is a developer library that lets us isolate the dependencies of the PDE solvers, like DiffEqBase. Where it differs is that it offers the common finite element tools &#40;like meshing&#41; and the types associated with PDEs, so this way other dev libraries which need these tools &#40;like DiffEqDevTools.jl&#41; do not require a solver &#40;and thus all of the solver dependencies&#41;. This doesn&#39;t have much of an actual change to users of DifferentialEquations.jl, but what it does mean is that test dependencies are now much more isolated. Also, by keeping the PDE setup separate from DiffEqBase, this will allow it to be much more dynamic, where as DiffEqBase is made to be a very stable library which just provides base functionality for ODEs/SDEs/DAEs/DDEs.</p> <p>This new setup shows how one can add PDE libraries to the setup. The PDE problems are defined in DiffEqPDEBase.jl. There&#39;s current a problem type for specifying a Poisson equation, and one for a Heat equation. More types of PDEs should be added, so please feel free to open a PR with new equation types &#40;even before we have solvers for them&#41;. Additionally, notice that the <code>mesh</code> is held in the problem definition. This means that the <code>Problem</code> type is a full computational specification of the problem to be solved, which allows for it to properly dispatch to the correct libraries and solvers. The <code>mesh</code> is parameteric, meaning that different <code>mesh</code>es can be specified and dispatched on. For example, a <code>FDMMesh</code> could be made to hold finite difference meshes, and then one could specify a finite difference heat problem by a change of mesh. Solvers can then dispatch based on the type of the mesh. Conversions between meshes can be done automatically to expand the reach of solvers &#40;within reason&#41;.</p> <p>FiniteElementDiffEq.jl then got a bit of an internal revamp. It got rid of a lot of dynamic dispatching, allowed for the familiar <code>solve&#40;prob,alg;kwargs...&#41;</code> form, and was just generally modernized / made to work well on v0.5 and v0.6. However, the solvers are still &quot;special-purpose&quot;. In the future, I will be getting rid of the special purpose solvers, and instead write them as calls to the ODE solver libraries, which will increase the performance given how well optimized those libraries are.</p> <p>Lastly, DiffEqParamEstim.jl got some updates which make it work in more cases. Essentially, if the parameters went into a bad zone, the ODE solvers would diverge, and this would cause an error. Now, this is treated as a parameter set with very high &#40;infinite&#41; cost, and therefore the optimization routines will still work naturally. The methods still have the limitation that they are made only for local minimization schemes using a non-weighted loss function &#40;local nonlinear least squares&#41;, so they are still sensitive to initial conditions. However, given this setup they should be easy to map over global optimization schemes. Bindings for MathProgBase/JuMP are coming soon which will allow for this.</p> <p>Next on the docket is the <code>integrator</code> interface. You&#39;ll see docs for this come live very shortly. Essentially, you can control ODEs step by step, and callbacks/ event handling got a major boost in applicability. This may be the new strongest part of the JuliaDiffEq. A separate post will handle this.</p> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>