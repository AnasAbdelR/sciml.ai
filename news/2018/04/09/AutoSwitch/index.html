<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 4.3: Automatic Stiffness Detection and Switching </title> <header> <h1><b><center>SciML Open Source Scientific Machine Learning</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>Okay, this is a quick release. However, There&#39;s so much good stuff coming out that I don&#39;t want them to overlap and steal each other&#39;s thunder&#33; This release has two long awaited features for increasing the ability to automatically solve difficult differential equations with less user input.</p> <h2 id=automatic_stiffness_detection_and_switching ><a href="#automatic_stiffness_detection_and_switching">Automatic Stiffness Detection and Switching</a></h2> <p>In order to numerically solve a differential equation efficiently, you need to use an explicit method for &quot;non-stiff&quot; problems and some more advanced form &#40;usually implicit&#41; whenever there is &quot;stiffness&quot;. These are not well-defined properties and thus it makes it really hard to teach how this should be done. However, the choice needs to be done because explicit methods will simply fail on stiff equations, but implicit methods have extra steps which are very costly, so they are inefficient if unnecessary. This is tedious to the user: why can&#39;t the software automatically determine which algorithm is appropriate?</p> <p>We can now. Thanks to Yingbo Ma &#40;@YingboMa&#41;, stiffness detection and switching algorithms are now part of OrdinaryDiffEq.jl and DelayDiffEq.jl. These algorithms utilize a cheap stiffness estimate to be able to detect when an explicit method is inefficient and automatically switch to an appropriate implicit method. Care is taken to ensure that the resulting continuous equation is still continuously differentiable &#40;and a little bit more&#41;.</p> <p>Benchmarks show that there is a very minimal &#40;&lt;5&#37;&#41; cost to enabling this, and thus these methods are the new defaults. Therefore most users should be able to automatically get appropriate methods without declaring stiffness. The ultimate goal of making <code>solve&#40;prob&#41;</code> &quot;the best choice&quot; is thus fairly well achieved.</p> <p>These methods are available to users as the <code>Auto</code> algorithms, like <code>AutoTsit5&#40;Rodas5&#40;&#41;&#41;</code> which does automatic switching between <code>Tsit5&#40;&#41;</code> and <code>Rodas5&#40;&#41;</code>. These methods also apply to delay differential equations. See the <a href="https://docs.juliadiffeq.org/latest/solvers/ode_solve">ODE solver docs for details</a>.</p> <h2 id=new_ssa_algorithmsoptimizations_mass_action_jumps ><a href="#new_ssa_algorithmsoptimizations_mass_action_jumps">New SSA Algorithms/Optimizations, Mass Action Jumps</a></h2> <p>One issue we had with our previous jump tooling is that it did not scale well to large numbers of jumps. Sam &#40;@isaacsas&#41; and Alfonso Landeros &#40;@alanderos91&#41; addressed this problem head on by creating a lot more jump problem tooling. The key issue is that the <code>rate</code> and <code>affect&#33;</code> functions are functions, and each function in Julia is a separate type. The tuple unpacking scheme is super fast for &lt;10 types, but then slows down. What is the best way to keep the generality but also scale well?</p> <p>First of all, they recognized that most jumps are due to mass-action terms which can be specialized. These terms don&#39;t need functions since we know the functional form one would make. <a href="https://docs.juliadiffeq.org/latest/types/jump_types">Thus now there&#39;s the <code>MassActionJump</code></a> which can hold the stoichiometry matrix for the mass action terms. These can hold all of the mass action terms, evaluate them efficiently, and reduce the number of functions that have to be handled. It has been <a href="https://docs.juliadiffeq.org/latest/tutorials/discrete_stochastic_example">added to the jump tutorial</a>.</p> <p>Next, <a href="https://docs.juliadiffeq.org/latest/types/jump_types">new SSAs were added</a>. There is the First Reaction Method <code>FRM&#40;&#41;</code> that can be used as an aggregation. In addition, the SSAs can now utilize FunctionWrappers.jl to efficiently scale to large vectors of functions. Thus there are new methods like <code>DirectFW&#40;&#41;</code> which utilize this strategy and will be more efficient when one has &gt;10 non mass-action terms.</p> <p>Together this is looking quite beautiful. These methods can all use the <code>SSAStepper&#40;&#41;</code> for pure-jump problems, but also these methods all compose with the ODE/SDE/DDE/DAE solvers to mix jumps and differential equations&#33;</p> <h2 id=large_noise_stable_methods_for_sdes ><a href="#large_noise_stable_methods_for_sdes">Large Noise Stable Methods for SDEs</a></h2> <p>Implicitness in the SDE algorithms only tends to be on the deterministic term. This means that large drift terms can be stable, but not necessarily large noise terms. Even worse, you cannot simply make an algorithm implicit in the noise term since then the mean of the steps is unbounded due to the inverse of the normal distribution&#33;</p> <p>But there have been many recent developments for methods called step splitting methods. These utilize a prediction via drift calculations and correct the noise calculation in a semi-implicit manner. The result is increased stability for large noise SDEs, usually without an additional cost. Given the effectiveness of this research, step-splitting has been incorporated in different ways throughout StochasticDiffEq.jl. These include:</p> <ol> <li><p><a href="https://docs.juliadiffeq.org/latest/solvers/sde_solve"><code>EM</code> and <code>LambaEM</code></a> have a choice to enable/disable step splitting. By default step splitting is enabled.</p> <li><p><a href="https://docs.juliadiffeq.org/latest/solvers/sde_solve">The <code>ISSEM</code> and <code>ISSEulerHeun</code> methods</a> are implemented which are implicit methods with step splitting, giving good stability in both the drift and noise terms. Additionally, these methods allow non-diagonal noise and have adaptive time stepping.</p> </ol> <p>Together, these algorithms can be much more efficient than the standard implementations when the noise term is large. Once again, these methods combine adaptivity which increases the amount of automation and the pool of methods which can be solved.</p> <h2 id=first-differences_in_parameter_estimation ><a href="#first-differences_in_parameter_estimation">First-Differences in Parameter Estimation</a></h2> <p>Parameter inference is improved by adding first differences terms. Instead of just checking the loss of the trajectory, this gives a loss on derivative approximations. This improves the identifiability, and also makes more models have fully observable parameters in the case of SDEs. Further improvements along these lines are scheduled as well.</p> <h1 id=in_development ><a href="#in_development">In development</a></h1> <p>There should be another set of new SDE solvers dropping within the next week. Additionally, there will be large improvements to the SSA choices for jump equations, allowing for different SSAs and different SSA implementations which are more efficient for large numbers of jumps. Here&#39;s a quick view of the rest of our &quot;in development&quot; list:</p> <ul> <li><p>Preconditioner choices for Sundials methods</p> <li><p>Adaptivity in the MIRK BVP solvers</p> <li><p>More general Banded and sparse Jacobian support outside of Sundials</p> <li><p>IMEX methods</p> <li><p>Function input for initial conditions and time span &#40;<code>u0&#40;p,t0&#41;</code>&#41;</p> <li><p>LSODA integrator interface</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>